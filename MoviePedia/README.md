# 📂 React TIL

> React의 데이터 관리를 학습한 내용입니다

## 🗂️ 학습내용

### 2025-08-06

**map을 이용해서 목록 렌더링**

- map을 이용해서 목록들을 렌더링해주는 컴포넌트를 만들 수 있다.


**filter로 아이템 삭제하기**

- 상위 컴포넌트에서 filter를 이용해서 아이템 삭제 함수 생성
- id값이랑 동일한 item을 제외하고 새로운 items 상를 생성 -> 상태가 변경되었으니 react는 리렌더링
- 하위 컴포넌트에서는 prop를 이용해 해당 id를 전달


**배열을 렌더링 필수 key**

- 요소의 순서가 바뀌면 input값 등이 엉뚱한 위치에 렌더링 될 수 있으므로 이를 방지하기 위해 필수적으로 key를 지정해줘야한다.
- key는 고유한 값을 사용해야한다.
- 배열의 변화를 정확하게 전달하기 위해서는 key값이 중요하다.

  - 만약 배열의 두번째 요소가 삭제되었다면 이것이 두번째 요소를 삭제한 것인지 마지막 요소를 삭제하고 두번째 요소를 변경했는지 알 수 없다. 그러나 key 값이 있다면 이를 명확히 알 수 있게 된다.

**useEffect**

- 컴포넌트가 처음 렌더링 되고 나면 리액트가 콜백 함수를 기억해뒀다가 실행한다.
- 이후 렌더링 할 때는 Dependency List에 있는 값들을 확인해서 하나라도 바뀌면 콜백 함수를 기억해뒀다가 실행한다.
- Dependency List가 빈 배열[ ]이면 처음과 달라지는 것이 없기때문에 맨처음 한 번만 실행된다. 


**Pagenation**

책의 페이지처럼 데이터를 나눠서 제공하는 것

- offset 기반
  - 지금까지 받아온 데이터를 기반으로 다음 데이터를 요청하는 것 
  - offset=20&limit=10 : 지금까지 20개를 받았으니 다음 10개를 요청
  - ⚠️ 문제 : 글을 보는 중에 데이터의 삭제나 추가가 일어나면 중복이나 생략이 일어날 수 있다.
- 커서 기반
  - 지금까지 받아온 데이터를 표시한 책갈피
  - cursor={nextCursor}&limit=10 : 커서를 기준으로 10개를 요청
  - ⚠️ 문제 : offset보다 만들기 까다롭고 데이터가 자주 바뀌는게 아니라면 offset으로 충분하다


**조건부 렌더링**

React에서 컴포넌트를 렌더링할 때 조건에 따라 다른 요소를 보여주는 방법

- AND 연산자
  - {show && 보인다 👀} : show 값이 true 이면 렌더링, false 이면 렌더링 하지 않는다.

- OR 연산자
  - {hide || 보인다 👀} : hide 값이 true 이면 렌더링 하지 않고, false 이면 렌더링

- 삼항 연산자 
  - {toggle ? ✅ : ❎} : toggle 의 값이 참일 경우엔 '✅'을, 거짓일 경우에는 '❎'를 렌더링


**함수형 업데이트**

비동기 함수에서 상태(state)를 사용할때, 항상 최신 상태를 유지하지 못할 수도 있다는 문제점이 있다. 
함수형 업데이트를 사용하면 리액트가 자동으로 이전 상태 인자를 넘겨주므로 최신 상태를 유지할 수 있게 된다.

함수형 업데이트를 사용해야 할 때

- 비동기 함수 내에서 상태를 변경할 때
- 여러 개의 상태 업데이트가 연달아 일어날 때
- 이전 상태에 기반해서 새 상태를 만들어야 할 때


**제어 컴포넌트**

- 인풋 태그의 value 속성을 지정하고 사용하는 컴포넌트.
- react에서 input의 값을 제어하는 경우로 react에서 지정한 값과 실제 input value 의 값이 항상 같다.
- 값을 예측하기가 쉽고 인풋에 쓰는 값을 여러 군데서 쉽게 바꿀 수 있다는 장점이 있어서 권장하는 방법.

**파일 컴포넌트**

- 파일 컴포넌트는 무조건 비제어 컴포넌트여야한다. 


**사이드 이펙트와 useEffect**

- useEffect는 리액트 컴포넌트 함수 안에서 사이드 이펙트를 실행하고 싶을 때 사용하는 함수
- 주로 리액트 외부에 있는 데이터나 상태를 변경할 때 사용
- 페이지 정보 변경, 네트워크 요청, 데이터 저장, 타이머 등에 사용
- useEffect는 사이트 이펙트를 정리하는 정리함수도 제공한다. (return {})